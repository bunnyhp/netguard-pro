{"fsPath":"\\home\\jarvis\\thesis\\experiments\\iot_profiler.py","fileUuid":"f3714124-0ea8-4703-8039-cdeff01d650a","fileSizeBytes":10118,"numLines":296,"diffChanges":[{"originalStartLineNumberOneIndexed":1,"originalEndLineNumberExclusiveOneIndexed":1,"modifiedStartLineNumberOneIndexed":1,"modifiedEndLineNumberExclusiveOneIndexed":297,"addedLines":["#!/usr/bin/env python3","\"\"\"","IoT Device Profiler (30-Day Campaign)","Purpose: Identify, classify, and profile IoT devices on the network","Duration: 30 days continuous profiling","\"\"\"","","import sqlite3","import json","import time","import requests","from datetime import datetime, timedelta","from collections import defaultdict, Counter","import sys","import os","","# Configuration","DB_PATH = \"/home/jarvis/NetGuard/network.db\"","DATA_DIR = \"/home/jarvis/thesis/data/iot_profiling\"","LOG_FILE = \"/home/jarvis/thesis/logs/iot_profiler.log\"","MAC_VENDOR_API = \"https://api.macvendors.com/\"","","# Device classification rules","DEVICE_PATTERNS = {","    'camera': {","        'vendors': ['hikvision', 'dahua', 'axis', 'wyze', 'ring', 'nest', 'arlo'],","        'ports': [554, 8080, 80, 443],  # RTSP, HTTP","        'protocols': ['RTSP', 'HTTP']","    },","    'smart_tv': {","        'vendors': ['samsung', 'lg', 'sony', 'vizio', 'tcl'],","        'ports': [443, 80, 8008, 8009],  # HTTP, Chromecast","        'protocols': ['HTTP', 'HTTPS', 'SSDP']","    },","    'smart_speaker': {","        'vendors': ['amazon', 'google', 'apple'],","        'ports': [443, 5353],  # HTTPS, mDNS","        'protocols': ['HTTPS', 'DNS', 'mDNS']","    },","    'router': {","        'vendors': ['netgear', 'linksys', 'tp-link', 'asus', 'belkin'],","        'ports': [80, 443, 53, 67],","        'protocols': ['HTTP', 'HTTPS', 'DNS', 'DHCP']","    },","    'smart_home': {","        'vendors': ['philips', 'wemo', 'tuya', 'smartthings'],","        'ports': [80, 443, 1883],  # HTTP, MQTT","        'protocols': ['HTTP', 'HTTPS', 'MQTT']","    },","    'phone': {","        'vendors': ['apple', 'samsung', 'google', 'oneplus', 'xiaomi'],","        'ports': [443, 5353],","        'protocols': ['HTTPS', 'mDNS', 'DNS']","    },","    'computer': {","        'vendors': ['dell', 'hp', 'lenovo', 'apple', 'asus', 'microsoft'],","        'ports': [80, 443, 22, 3389],","        'protocols': ['HTTP', 'HTTPS', 'SSH', 'RDP']","    }","}","","os.makedirs(DATA_DIR, exist_ok=True)","os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)","","def log(message):","    \"\"\"Log message with timestamp\"\"\"","    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')","    log_msg = f\"[{timestamp}] {message}\"","    print(log_msg)","    with open(LOG_FILE, 'a') as f:","        f.write(log_msg + '\\n')","","def get_mac_vendor(mac_address):","    \"\"\"Lookup MAC vendor (with rate limiting)\"\"\"","    try:","        response = requests.get(f\"{MAC_VENDOR_API}{mac_address}\", timeout=5)","        if response.status_code == 200:","            return response.text.strip()","        time.sleep(1)  # Rate limiting","        return \"Unknown\"","    except:","        return \"Unknown\"","","def classify_device(ip, mac, vendor, ports, protocols, traffic_volume):","    \"\"\"Classify device type based on patterns\"\"\"","    vendor_lower = vendor.lower()","    ","    # Check each device type","    for device_type, patterns in DEVICE_PATTERNS.items():","        score = 0","        ","        # Vendor match (highest weight)","        if any(v in vendor_lower for v in patterns['vendors']):","            score += 10","        ","        # Port match","        matching_ports = set(ports) & set(patterns['ports'])","        score += len(matching_ports) * 2","        ","        # Protocol match","        matching_protocols = set(protocols) & set(patterns['protocols'])","        score += len(matching_protocols)","        ","        if score >= 5:  # Threshold for classification","            return device_type, score","    ","    # Default classification","    if traffic_volume > 100000:  # High traffic","        return 'computer', 0","    elif traffic_volume < 1000:  # Low traffic","        return 'iot_generic', 0","    else:","        return 'unknown', 0","","def calculate_security_score(device_data):","    \"\"\"Calculate device security score (0-100)\"\"\"","    score = 100","    ","    # Open insecure ports (-20 points each)","    insecure_ports = [23, 21, 80]  # Telnet, FTP, HTTP","    for port in insecure_ports:","        if port in device_data.get('ports', []):","            score -= 20","    ","    # Unencrypted traffic (-15 points)","    if device_data.get('unencrypted_percent', 0) > 50:","        score -= 15","    ","    # Default credentials detection (-30 points)","    if device_data.get('default_creds_detected', False):","        score -= 30","    ","    # Outdated firmware indicators (-10 points)","    if device_data.get('old_user_agent', False):","        score -= 10","    ","    # Suspicious connections (-15 points)","    if device_data.get('suspicious_connections', 0) > 0:","        score -= 15","    ","    # No encryption usage (-10 points)","    if 'HTTPS' not in device_data.get('protocols', []) and 'TLS' not in device_data.get('protocols', []):","        score -= 10","    ","    return max(0, min(100, score))","","def profile_devices(day):","    \"\"\"Profile all devices for a given day\"\"\"","    log(f\"Profiling devices for Day {day}...\")","    ","    conn = sqlite3.connect(DB_PATH)","    conn.row_factory = sqlite3.Row","    cursor = conn.cursor()","    ","    devices = {}","    ","    try:","        # Get latest p0f data","        cursor.execute(\"\"\"","            SELECT name FROM sqlite_master ","            WHERE type='table' AND name LIKE 'p0f_%' ","            AND name NOT LIKE '%_template'","            ORDER BY name DESC LIMIT 5","        \"\"\")","        p0f_tables = [row[0] for row in cursor.fetchall()]","        ","        for table in p0f_tables:","            cursor.execute(f\"SELECT src_ip, src_mac, os_name, os_flavor FROM {table}\")","            for row in cursor.fetchall():","                ip = row['src_ip']","                mac = row['src_mac'] if row['src_mac'] else 'unknown'","                ","                if ip not in devices:","                    devices[ip] = {","                        'ip': ip,","                        'mac': mac,","                        'os': row['os_name'] if row['os_name'] else 'Unknown',","                        'os_details': row['os_flavor'] if row['os_flavor'] else '',","                        'ports': set(),","                        'protocols': set(),","                        'traffic_bytes': 0,","                        'connections': 0,","                        'vendor': 'Unknown'","                    }","        ","        # Get traffic data from tshark","        cursor.execute(\"\"\"","            SELECT name FROM sqlite_master ","            WHERE type='table' AND name LIKE 'tshark_%' ","            AND name NOT LIKE '%_template'","            ORDER BY name DESC LIMIT 5","        \"\"\")","        tshark_tables = [row[0] for row in cursor.fetchall()]","        ","        for table in tshark_tables:","            cursor.execute(f\"\"\"","                SELECT src_ip, dest_port, protocol, frame_length ","                FROM {table} ","                WHERE dest_port IS NOT NULL","            \"\"\")","            for row in cursor.fetchall():","                ip = row['src_ip']","                if ip in devices:","                    if row['dest_port']:","                        devices[ip]['ports'].add(int(row['dest_port']))","                    if row['protocol']:","                        devices[ip]['protocols'].add(row['protocol'])","                    if row['frame_length']:","                        devices[ip]['traffic_bytes'] += int(row['frame_length'])","                    devices[ip]['connections'] += 1","        ","        # Classify and score devices","        device_profiles = []","        for ip, data in devices.items():","            # Get vendor","            if data['mac'] != 'unknown':","                data['vendor'] = get_mac_vendor(data['mac'])","                time.sleep(1.5)  # Rate limiting for API","            ","            # Classify","            device_type, confidence = classify_device(","                ip,","                data['mac'],","                data['vendor'],","                list(data['ports']),","                list(data['protocols']),","                data['traffic_bytes']","            )","            ","            # Calculate security score","            security_score = calculate_security_score(data)","            ","            profile = {","                'ip': ip,","                'mac': data['mac'],","                'vendor': data['vendor'],","                'os': data['os'],","                'os_details': data['os_details'],","                'device_type': device_type,","                'classification_confidence': confidence,","                'open_ports': sorted(list(data['ports'])),","                'protocols_used': sorted(list(data['protocols'])),","                'total_traffic_bytes': data['traffic_bytes'],","                'total_connections': data['connections'],","                'security_score': security_score,","                'day': day,","                'timestamp': datetime.now().isoformat()","            }","            ","            device_profiles.append(profile)","        ","        # Save profiles","        output_file = os.path.join(DATA_DIR, f\"day{day}_device_profiles.json\")","        with open(output_file, 'w') as f:","            json.dump(device_profiles, f, indent=2, default=str)","        ","        log(f\"Profiled {len(device_profiles)} devices. Saved to {output_file}\")","        ","        # Generate summary","        device_types = Counter([d['device_type'] for d in device_profiles])","        log(f\"Device type distribution: {dict(device_types)}\")","        ","        avg_security_score = sum(d['security_score'] for d in device_profiles) / len(device_profiles) if device_profiles else 0","        log(f\"Average security score: {avg_security_score:.2f}/100\")","        ","    except Exception as e:","        log(f\"ERROR: {str(e)}\")","    finally:","        conn.close()","","def main():","    \"\"\"Main profiling loop\"\"\"","    log(\"=\"*60)","    log(\"IoT Device Profiler - 30-Day Campaign Started\")","    log(f\"Started: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")","    log(\"=\"*60)","    ","    for day in range(1, 31):","        log(f\"\\n=== Day {day} of 30 ===\")","        profile_devices(day)","        ","        # Profile once per day (at midnight or whenever script runs)","        if day < 30:","            log(f\"Waiting 24 hours for Day {day+1}...\")","            time.sleep(86400)  # 24 hours","    ","    log(\"=\"*60)","    log(\"IoT Device Profiling COMPLETED\")","    log(f\"Completed: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\")","    log(f\"Data location: {DATA_DIR}\")","    log(\"=\"*60)","","if __name__ == \"__main__\":","    main()","",""],"tokenizedAddedLines":[1000000,1000001,1000002,1000003,1000004,1000001,1000005,1000006,1000007,1000008,1000009,1000010,1000011,1000012,1000013,1000005,1000014,1000015,1000016,1000017,1000018,1000005,1000019,1000020,1000021,1000022,1000023,1000024,1000025,1000026,1000027,1000028,1000029,1000025,1000030,1000031,1000032,1000033,1000025,1000034,1000035,1000036,1000037,1000025,1000038,1000039,1000040,1000041,1000025,1000042,1000043,1000044,1000045,1000025,1000046,1000047,1000048,1000049,1000050,1000051,1000005,1000052,1000053,1000005,1000054,1000055,1000056,1000057,1000058,1000059,1000060,1000005,1000061,1000062,1000063,1000064,1000065,1000066,1000067,1000068,1000069,1000068,1000005,1000070,1000071,1000072,1000073,1000074,1000075,1000076,1000077,1000078,1000079,1000080,1000077,1000081,1000082,1000083,1000077,1000084,1000085,1000086,1000077,1000087,1000088,1000073,1000089,1000090,1000091,1000092,1000093,1000094,1000095,1000005,1000096,1000097,1000098,1000073,1000099,1000100,1000101,1000102,1000103,1000073,1000104,1000105,1000106,1000073,1000107,1000108,1000109,1000073,1000110,1000111,1000112,1000073,1000113,1000114,1000106,1000073,1000115,1000116,1000112,1000073,1000117,1000005,1000118,1000119,1000120,1000073,1000121,1000122,1000123,1000073,1000124,1000073,1000063,1000125,1000126,1000127,1000128,1000129,1000130,1000131,1000132,1000077,1000133,1000134,1000135,1000136,1000137,1000138,1000139,1000140,1000141,1000142,1000143,1000144,1000145,1000146,1000147,1000148,1000149,1000150,1000077,1000151,1000126,1000127,1000152,1000129,1000130,1000131,1000153,1000077,1000154,1000155,1000156,1000157,1000158,1000159,1000135,1000136,1000160,1000161,1000162,1000163,1000164,1000165,1000166,1000167,1000077,1000168,1000169,1000170,1000171,1000172,1000173,1000174,1000175,1000176,1000177,1000178,1000179,1000180,1000181,1000182,1000183,1000184,1000175,1000185,1000186,1000175,1000187,1000188,1000189,1000190,1000191,1000192,1000193,1000194,1000195,1000196,1000197,1000198,1000199,1000200,1000201,1000202,1000175,1000203,1000077,1000204,1000205,1000206,1000207,1000077,1000208,1000077,1000209,1000210,1000211,1000077,1000212,1000213,1000077,1000214,1000215,1000216,1000217,1000005,1000218,1000219,1000220,1000221,1000222,1000220,1000073,1000223,1000224,1000225,1000077,1000226,1000227,1000228,1000229,1000073,1000220,1000230,1000231,1000232,1000220,1000005,1000233,1000234,1000005,1000005]}],"gitInfo":{"noRepoFound":true},"kind":"KIND_ADDED"}