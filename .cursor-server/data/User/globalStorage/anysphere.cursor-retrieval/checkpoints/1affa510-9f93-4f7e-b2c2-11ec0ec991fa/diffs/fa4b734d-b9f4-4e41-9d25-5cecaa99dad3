{"fsPath":"\\home\\jarvis\\NetGuard\\scripts\\nethogs_collector.py","fileUuid":"fa4b734d-b9f4-4e41-9d25-5cecaa99dad3","fileSizeBytes":7189,"numLines":233,"diffChanges":[{"originalStartLineNumberOneIndexed":1,"originalEndLineNumberExclusiveOneIndexed":1,"modifiedStartLineNumberOneIndexed":1,"modifiedEndLineNumberExclusiveOneIndexed":234,"addedLines":["#!/usr/bin/env python3","\"\"\"","NetGuard Pro - nethogs Collector","Per-process network bandwidth monitoring","\"\"\"","","import os","import subprocess","import sqlite3","import logging","import time","import re","from datetime import datetime","","# Configuration","INTERFACE = \"eno1\"","CAPTURE_DIR = \"/home/jarvis/NetGuard/captures/nethogs\"","DB_PATH = \"/home/jarvis/NetGuard/network.db\"","LOG_FILE = \"/home/jarvis/NetGuard/logs/system/nethogs-collector.log\"","COLLECT_INTERVAL = 30  # Collect every 30 seconds","CAPTURE_DURATION = 10  # Capture for 10 seconds","","# Setup logging","logging.basicConfig(","    level=logging.INFO,","    format='%(asctime)s - %(levelname)s - %(message)s',","    handlers=[","        logging.FileHandler(LOG_FILE),","        logging.StreamHandler()","    ]",")","","def create_table(conn, table_name):","    \"\"\"Create nethogs table if it doesn't exist\"\"\"","    cursor = conn.cursor()","    sql = f\"\"\"","    CREATE TABLE IF NOT EXISTS {table_name} (","        id INTEGER PRIMARY KEY AUTOINCREMENT,","        timestamp TEXT NOT NULL,","        program TEXT,","        pid INTEGER,","        user TEXT,","        sent_kb REAL,","        received_kb REAL,","        created_at DATETIME DEFAULT CURRENT_TIMESTAMP","    );","    \"\"\"","    cursor.execute(sql)","    conn.commit()","","def parse_nethogs_line(line):","    \"\"\"Parse nethogs trace mode output line\"\"\"","    try:","        # nethogs trace mode format (tab-separated):","        # /full/path/to/program/pid  sent_kb  received_kb","        # or: program/pid  sent_kb  received_kb","        ","        parts = line.split('\\t')","        ","        if len(parts) < 3:","            # Try space-separated","            parts = line.split()","        ","        if len(parts) < 3:","            return None","        ","        data = {}","        ","        # Parse program/PID","        prog_pid = parts[0].strip()","        ","        # Extract PID (usually last number after /)","        pid_match = re.search(r'/(\\d+)$', prog_pid)","        if pid_match:","            data['pid'] = int(pid_match.group(1))","            # Get program name (everything before /PID)","            data['program'] = prog_pid[:pid_match.start()]","        else:","            # Try to parse differently","            pid_parts = prog_pid.split('/')","            if pid_parts[-1].isdigit():","                data['pid'] = int(pid_parts[-1])","                data['program'] = '/'.join(pid_parts[:-1])","            else:","                data['program'] = prog_pid","                data['pid'] = None","        ","        # Clean up program name (remove leading slashes, get basename)","        if data['program']:","            program_parts = data['program'].split('/')","            data['program'] = program_parts[-1] if program_parts[-1] else data['program']","        ","        # Parse sent KB","        try:","            sent = parts[1].strip()","            data['sent_kb'] = float(sent) if sent and sent != '?' else 0.0","        except:","            data['sent_kb'] = 0.0","        ","        # Parse received KB","        try:","            received = parts[2].strip()","            data['received_kb'] = float(received) if received and received != '?' else 0.0","        except:","            data['received_kb'] = 0.0","        ","        # User (if available in parts[3])","        if len(parts) > 3:","            data['user'] = parts[3].strip()","        else:","            data['user'] = ''","        ","        data['timestamp'] = datetime.now().isoformat()","        ","        return data","        ","    except Exception as e:","        logging.debug(f\"Error parsing nethogs line: {e}\")","        return None","","def collect_nethogs_data():","    \"\"\"Collect per-process bandwidth data using nethogs\"\"\"","    try:","        logging.info(\"Collecting nethogs data...\")","        ","        # Run nethogs in trace mode","        # -t: trace mode (machine readable)","        # -d: delay between updates (seconds)","        # interface: eno1","        ","        # Use timeout to limit collection duration","        cmd = [","            'timeout', str(CAPTURE_DURATION),","            'sudo', 'nethogs',","            '-t',","            '-d', '1',","            INTERFACE","        ]","        ","        result = subprocess.run(cmd, capture_output=True, text=True, timeout=CAPTURE_DURATION + 5)","        ","        # nethogs with timeout returns 124, which is expected","        if not result.stdout:","            logging.warning(\"No nethogs data captured\")","            return","        ","        # Parse output","        lines = result.stdout.strip().split('\\n')","        entries = []","        ","        for line in lines:","            line = line.strip()","            if not line or line.startswith('Refreshing') or line.startswith('/'):","                # Skip header lines","                if 'PID' in line or 'USER' in line:","                    continue","            ","            parsed = parse_nethogs_line(line)","            if parsed and parsed.get('program'):","                entries.append(parsed)","        ","        if not entries:","            logging.debug(\"No entries parsed from nethogs\")","            return","        ","        # Create table","        timestamp_str = datetime.now().strftime('%Y%m%d_%H%M%S')","        table_name = f\"nethogs_{timestamp_str}\"","        ","        conn = sqlite3.connect(DB_PATH)","        create_table(conn, table_name)","        cursor = conn.cursor()","        ","        # Insert entries","        inserted = 0","        for entry in entries:","            try:","                cursor.execute(f\"\"\"","                    INSERT INTO {table_name}","                    (timestamp, program, pid, user, sent_kb, received_kb)","                    VALUES (?, ?, ?, ?, ?, ?)","                \"\"\", (","                    entry.get('timestamp'),","                    entry.get('program', ''),","                    entry.get('pid'),","                    entry.get('user', ''),","                    entry.get('sent_kb', 0.0),","                    entry.get('received_kb', 0.0)","                ))","                inserted += 1","            except Exception as e:","                logging.debug(f\"Error inserting entry: {e}\")","                continue","        ","        conn.commit()","        conn.close()","        ","        if inserted > 0:","            logging.info(f\"âœ“ Inserted {inserted} process bandwidth records into '{table_name}'\")","        ","    except subprocess.TimeoutExpired:","        logging.debug(\"nethogs collection completed (expected timeout)\")","    except Exception as e:","        logging.error(f\"Error collecting nethogs data: {e}\")","","def main():","    \"\"\"Main collection loop\"\"\"","    logging.info(\"=\" * 60)","    logging.info(\"NetGuard Pro - nethogs Collector\")","    logging.info(\"=\" * 60)","    logging.info(f\"Interface: {INTERFACE}\")","    logging.info(f\"Collection interval: {COLLECT_INTERVAL} seconds\")","    logging.info(f\"Capture duration: {CAPTURE_DURATION} seconds\")","    logging.info(\"=\" * 60)","    ","    os.makedirs(CAPTURE_DIR, exist_ok=True)","    os.makedirs(os.path.dirname(LOG_FILE), exist_ok=True)","    ","    while True:","        try:","            collect_nethogs_data()","            time.sleep(COLLECT_INTERVAL)","        except KeyboardInterrupt:","            logging.info(\"Shutting down nethogs collector...\")","            break","        except Exception as e:","            logging.error(f\"Error in main loop: {e}\")","            time.sleep(COLLECT_INTERVAL)","","if __name__ == \"__main__\":","    main()","",""],"tokenizedAddedLines":[1000000,1000001,1000002,1000003,1000001,1000004,1000005,1000006,1000007,1000008,1000009,1000010,1000011,1000004,1000012,1000013,1000014,1000015,1000016,1000017,1000018,1000004,1000019,1000020,1000021,1000022,1000023,1000024,1000025,1000026,1000027,1000004,1000028,1000029,1000030,1000031,1000032,1000033,1000034,1000035,1000036,1000037,1000038,1000039,1000040,1000041,1000042,1000043,1000044,1000004,1000045,1000046,1000047,1000048,1000049,1000050,1000051,1000052,1000051,1000053,1000054,1000055,1000051,1000053,1000056,1000051,1000057,1000051,1000058,1000059,1000051,1000060,1000061,1000062,1000063,1000064,1000065,1000066,1000067,1000068,1000069,1000070,1000071,1000072,1000073,1000074,1000051,1000075,1000076,1000077,1000078,1000051,1000079,1000080,1000081,1000082,1000083,1000084,1000051,1000085,1000080,1000086,1000087,1000083,1000088,1000051,1000089,1000090,1000091,1000066,1000092,1000051,1000093,1000051,1000094,1000051,1000095,1000096,1000097,1000004,1000098,1000099,1000047,1000100,1000051,1000101,1000102,1000103,1000104,1000051,1000105,1000106,1000107,1000108,1000109,1000110,1000111,1000112,1000051,1000113,1000051,1000114,1000115,1000116,1000117,1000051,1000118,1000119,1000120,1000051,1000121,1000122,1000123,1000124,1000125,1000126,1000127,1000128,1000129,1000130,1000051,1000131,1000132,1000117,1000051,1000133,1000134,1000135,1000051,1000136,1000137,1000138,1000051,1000139,1000140,1000141,1000142,1000143,1000144,1000145,1000146,1000147,1000148,1000149,1000150,1000151,1000152,1000153,1000154,1000155,1000156,1000157,1000158,1000051,1000159,1000160,1000051,1000161,1000162,1000051,1000163,1000164,1000095,1000165,1000004,1000166,1000167,1000168,1000169,1000168,1000170,1000171,1000172,1000168,1000173,1000174,1000175,1000173,1000176,1000080,1000177,1000178,1000179,1000180,1000181,1000182,1000183,1000178,1000004,1000184,1000185,1000004,1000004]}],"gitInfo":{"noRepoFound":true},"kind":"KIND_ADDED"}